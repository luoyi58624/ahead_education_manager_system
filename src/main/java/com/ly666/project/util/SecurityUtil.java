package com.ly666.project.util;import com.auth0.jwt.JWT;import com.auth0.jwt.JWTVerifier;import com.auth0.jwt.algorithms.Algorithm;import com.auth0.jwt.exceptions.JWTDecodeException;import com.auth0.jwt.exceptions.TokenExpiredException;import com.auth0.jwt.interfaces.DecodedJWT;import com.ly666.project.global.defaultValue.GlobalProperties;import lombok.extern.slf4j.Slf4j;import org.apache.shiro.crypto.hash.Md5Hash;import javax.validation.constraints.NotBlank;import java.io.UnsupportedEncodingException;import java.util.Date;/** * @author ：luoyi * @date ：Created in 2019/5/13 20:24 * @desc : {签名/加密/解析工具类} */@Slf4jpublic class SecurityUtil {	/**	 * shiro密码加密工具类	 *	 * @param credentials 密码	 * @return  返回未加盐的密码	 */	public static String generaPassword(String credentials) {		return new Md5Hash(credentials).toString();	}	/**	 * shiro密码加密工具类	 *	 * @param credentials 密码	 * @param saltSource  密码盐	 * @return   返回加盐的密码	 */	public static String generaPassword(String credentials, String saltSource) {		return new Md5Hash(credentials, saltSource + GlobalProperties.HASH_SALT, GlobalProperties.HASH_ITERATIONS).toString();	}	/**	 * 生成签名,5min后过期	 * @param account  用户账号	 * @param secret   用户的密码	 * @return 加密的token	 */	public static String sign(@NotBlank String account,@NotBlank String secret) {		Date date = new Date(System.currentTimeMillis() + GlobalProperties.JWT_EXPIRE_TIME);		Algorithm algorithm = null;		try {			algorithm = Algorithm.HMAC256(secret);		} catch (UnsupportedEncodingException e) {			e.printStackTrace();		}		// 附带username信息		assert algorithm != null;		return JWT.create()				.withClaim("account", account)				.withExpiresAt(date)				.sign(algorithm);	}	/**	 * 校验token是否正确	 *	 * @param token  密钥	 * @param account 用户的账号	 * @param secret 用户的密码	 * @return 是否正确	 */	public static boolean verify(String token, String account, String secret){		Algorithm algorithm = null;		try {			algorithm = Algorithm.HMAC256(secret);		} catch (UnsupportedEncodingException e) {			e.printStackTrace();		}		assert algorithm != null;		//构建匹配器		JWTVerifier verifier = JWT.require(algorithm).withClaim("account", account).build();		try {			//开始验证token，如果失败则返回false			verifier.verify(token);		}catch (JWTDecodeException | TokenExpiredException e){			log.debug("token验证失败");			return false;		}		return true;	}	/**	 * 获得token中的账号信息无需secret解密也能获得	 * @return token中包含的用户名	 */	public static String getAccount(String token) {		DecodedJWT jwt;		try {			jwt = JWT.decode(token);		} catch (JWTDecodeException e) {			throw new JWTDecodeException("token解析异常");		}		return jwt.getClaim("account").asString();	}}