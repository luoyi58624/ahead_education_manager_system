package com.ly666.ahead.security.shiro;import com.ly666.ahead.security.model.auth.AuthType;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.pam.ModularRealmAuthenticator;import org.apache.shiro.realm.Realm;import org.springframework.util.StringUtils;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.List;/** * @author ：luoyi * @date ：Created in 2019/5/30 11:30 * @desc : {自定义的realm的匹配器} */public class CustomModularRealm extends ModularRealmAuthenticator {	/**	 * 重写认证方式，它会根据{@link com.ly666.ahead.security.model.auth.AuthType}定义的token认证类型来进行匹配不同的realm	 */	@Override	protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException {		// 判断getRealms()是否返回为空		assertRealmsConfigured();		// 获取所有Realm		Collection<Realm> realms = getRealms();		AuthType jwtToken = (AuthType) authenticationToken;		//如果认证类型只存在一个时，则仅返回一个AuthenticationInfo	    if (!StringUtils.isEmpty(jwtToken.getAuthType()) && StringUtils.isEmpty(jwtToken.getAuthTypes())){	    	for (Realm realm : realms){			    if (Integer.valueOf(realm.getName().split("_")[1]).equals(jwtToken.getAuthType())) {				    return doSingleRealmAuthentication(realm, authenticationToken);			    }		    }	    }		if (StringUtils.isEmpty(jwtToken.getAuthType()) && !StringUtils.isEmpty(jwtToken.getAuthTypes())){			HashSet<Integer> authTypes = jwtToken.getAuthTypes();			List<Realm> typeRealms = new ArrayList<>();			for (Integer authType : authTypes) {				for (Realm realm : realms) {					if (Integer.valueOf(realm.getName().split("_")[1]).equals(authType)) {						typeRealms.add(realm);					}				}			}			return doMultiRealmAuthentication(typeRealms, authenticationToken);		}		return null;	}}